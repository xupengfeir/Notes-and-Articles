# C++基础问题解答

**1、解释C++中指针和引用并说明两者的区别。**  
（1）指针是一个变量，它保存了另一个变量的内存地址；引用是另一个变量的别名，与原变量共享内存地址。  
（2）指针可以被重新赋值，指向不同的变量；引用在初始化后不能更改，始终指向同一个变量。  
（3）指针可以为nullptr，表示不指向任何变量；引用必须绑定到一个变量，不能为nullptr。  
（4）使用指针需要对其进行解引用以获取或修改其指向的变量的值；引用可以直接使用，无需解引用。  
*在汇编层面，引用会被C++编译器当作const指针来进行操作。*

**2、C++中的多态性是什么？有哪些实现方法。**  
在C++中，多态性是面向对象编程的一个重要概念。它允许不同类的对象对同一消息做出不同的相应。简单来说，多态性就是同一个接口，针对不同的对象会有不同的实现方式。  
实现方式：  
**（1）虚函数：** 在基类中声明虚函数，在派生类中重新实现这些函数。当使用基类指针或引用指向派生类对象时，通过这个指针或引用调用虚函数时，将会根据实际对象的类型来待用相应的函数。这种方式实现了运行时多态性。  
```
class Base {
public:
    virtual void print() {
        cout << "Base class print function" << endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        cout << "Derived class print function" << endl;
    }
};

int main() {
    Base *basePtr;
    Derived derivedObj;
    
    basePtr = &derivedObj;
    
    // 调用派生类的print函数
    basePtr->print();
    
    return 0;
}

```
**(2)纯虚函数和抽象类：** 在基类中声明纯虚函数，它没有函数体，然后派生类必须实现这个函数。如果基类中包含纯虚函数，那么这个类就是一个抽象类，不能实例化对象，只能作为借口被其他类继承。抽象类中的纯虚函数提供了接口规范，而具体的实现由派生类来完成。
```
class AbstractShape {
public:
    // 纯虚函数
    virtual void draw() = 0;
};

class Circle : public AbstractShape {
public:
    void draw() override {
        cout << "Drawing a circle" << endl;
    }
};

class Square : public AbstractShape {
public:
    void draw() override {
        cout << "Drawing a square" << endl;
    }
};

int main() {
    Circle circle;
    Square square;
    
    circle.draw();
    square.draw();
    
    return 0;
}

```
**(3)函数重载：**  C++允许在同一个作用域中声明多个同名函数，只要他们的参数列表不同即可通过函数重载，可以根据函数参数的不同来调用不同的函数。这种实现方式实现了编译时的多态性。


**3、什么是作用域解析运算符（::）？它在C++中的作用？**   
作用域解析运算符(::)在C++中用于指定命名空间、类、结构体或枚举中的特定成员的作用域。它的基本形式是是`namespace::member`或`class::member`，其中`namespace`是命名空间的名称，`class`是类的名称，`member`是类、命名空间、结构体或枚举中的成员的名称。  
作用域解析运算符(::)作用：  
**（1）访问命名空间的成员：** 当在一个命名空间中定义了多个具有相同名称的成员时，可以使用作用域解析运算符来指定具体要使用的成员。   
**（2）访问类的静态成员：** 当类具有静态成员时，可以使用作用域解析运算符来访问这些静态成员。  
```
class MyClass {
public:
    static int staticValue;
};
int MyClass::staticValue = 20;
int main() {
    int value = MyClass::staticValue; // 访问类的静态成员
    return 0;
}
```
**（3）在类的定义外定义成员函数：** 当在类的定义外定义成员函数时，需要使用作用域解析运算符来指定函数属于哪个类。  
作用域解析运算符使得在复杂的命名空间和类的层次结构中能够清晰地指定成员的作用域，避免了命名冲突，提高了代码的可读性和维护性。

**4、解释C++中的析构函数和构造函数，并说明它们的作用？**  
C++中，构造函数和析构函数是用于对象的创建和销毁的特殊成员函数。  

**（1）构造函数：** 构造函数是一种特殊的成员函数，在创建对象时被调用，用于初始化对象的数据成员。构造函数的名称与类名相同，没有返回类型，可以有多个构造函数（重载），可以有参数，也可以没有参数。当创建一个对象时，构造参数负责初始化对象的状态。  

**（2）析构函数：** 析构函数是一种特殊的成员函数，在对象被销毁时自动调用，用于清理对象占用的资源。析构函数的名称和类名相同，前面加上波浪号（~），没有返回类型，不接受任何参数。当对象超出范围、程序退出或delete运算符被调用时，析构函数会被自动调用。  
析构函数通常用于释放动态分配的内存、关闭文件、释放资源等清理工作。如果不显式提供析构函数，编译器会生成一个默认的析构函数，该默认析构函数没有任何操作。

**5、什么是动态内存分配？在C++中如何进行动态内存分配？**  
动态内存分配是指在程序运行时根据需要动态地分配内存空间。与静态内存分配不同，静态内存分配是在**编译时**确定内存分配大小和位置的，而动态内存分配是在**程序运行时**根据需要分配和释放内存。  
C++中使用两个关键字来进行动态内存分配和释放。   

1、**new操作符：** new操作符用于动态地分配内存并返回该内存的地址。通过new操作符分配的内存空间在堆（heap）中，它的生存期由程序员控制。  
使用new分配的内存空间一定要在不需要时及时释放，否则会造成内存泄漏。
```
// 分配一个 int 类型的内存空间并返回指针
int *ptr = new int;
// 分配一个 int 数组的内存空间并返回指针
int *arr = new int[10];
```
2、**delete操作符：** delete操作符用于释放由new操作符分配的动态内存空间。delete操作符释放的是通过new操作符分配的单个对象或数组。  
必须确保在不再使用动态分配的内存空间时，及时使用delete操作符释放该内存，否则会造成内存泄漏。不正确地使用delete操作符可能会导致一些问题。比如悬挂指针（ **指向一个被释放的内存地址** ）或者释放同一内存块多次。
```
delete ptr;  // 释放单个对象
delete[] arr;  // 释放数组
```

**6、解释C++中的友元函数和友元类，并说明它们的作用。**  
在C++中，友元函数和友元类是用来访问类的私有成员的特殊机制。  
**1、友元函数（Friend Function）：** 友元函数是指被声明为类的友元的非成员函数。这意味着友元函数可以直接访问类的私有成员和保护成员，而不受访问权限的限制。将一个函数声明为类的友元，可以在类的声明中使用 **‘friend’** 关键字。  
```
class MyClass {
private:
    int x;
public:
    friend void friendFunction(MyClass obj);
};

void friendFunction(MyClass obj) {
    // 可以访问 MyClass 的私有成员 x
    cout << "Friend function accessing private member: " << obj.x << endl;
}
```
**2、友元类（Friend Class）：** 友元类是指被声明为另一个类的友元的类。这意味着友元类可以访问被友元类声明为友元的类的私有成员和保护成员。要将一个类声明成另一个类的友元，可以在类的声明中使用 **‘friend’** 关键字。
```
class MyClass {
private:
    int x;
public:
    friend class FriendClass;
};

class FriendClass {
public:
    void accessPrivateMember(MyClass obj) {
        // 可以访问 MyClass 的私有成员 x
        cout << "Friend class accessing private member: " << obj.x << endl;
    }
};
```
**作用：**  
（1）访问私有成员：允许非成员函数或其他类的成员函数访问类的私有成员。  
（2）提供更灵活的设计：在不违反封装原则的前提下让外部函数或类访问私有成员。  
（3）增加效率：可以在需要时允许特定的函数或类访问私有成员，而不必将这些成员声明为公共的，从而减少类的接口大小，提高封装性。

**7、什么是命名空间？为什么需要命名空间？**
命名空间（Namespace）是C++中用来组织代码和避免命名冲突的机制。它允许将全局作用域划分为一个个小的子集，每个子集可以拥有自己独立的标识符（变量、函数、类等），从而提供了更清晰、更可管理的代码结构。  

命名空间的声明：  
```
namespace mynamespace {
    // 声明属于 mynamespace 命名空间的标识符
    int x;
    void foo();
}
```
访问：
```
mynamespace::x = 10;
mynamespace::foo();
```
1、避免命名冲突。  
2、提高代码可读性和维护性。  
3、模块化和组织代码。  
4、限定标识符的作用域。

**8、在C++中如何进行类型转换？有哪些类型的转换方式?**  
**（1）隐式类型转换：** 编译器自动进行类型转换，称为隐式转换。例如不同类型变量之间的赋值操作。  
**（2）显示类型转换：**  
1）C风格的类型转换：使用旧式的C风格类型转换，包括static_cast、dynamic_cast、reinterpret_cast和const_cast。  

2）C++中的类型转换运算符：C++中的强制类型转换运算符包括static_cast、dynamic_cast、reinterpret_cast和const_cast。这些运算符提供了更加安全和可读的类型转换方式。

3）static_cast：用于基本类型之间的转换，以及具有继承关系的指针或引用类型之间的转换。

4）dynamic_cast：用于在继承关系中进行安全的向下转换（派生类到基类），需要基类为多态类型（至少有一个虚函数）。

5）reinterpret_cast：进行低级别的类型转换，例如将一个整数类型的指针转换为一个指向另一种类型的指针。

6）const_cast：用于去除指针或引用的const属性。

**9、C++中dynamic_cast有什么特殊之处？**  
用于继承关系中进行安全的向下转换（派生类到基类），需要基类为多态类型（至少有一个虚函数）。


**10、什么是异常处理？在C++中如何处理异常？**  
异常处理是一种在程序执行过程中检测和响应异常情况的机制。异常是指程序在执行期间发生的意外或者异常的情况，例如除以零、访问无效的内存、文件不存在等。异常处理的目的是使程序能够优雅地处理异常情况，而不是直接崩溃或导致不可预测的行为。  
**·try：** 用于包含可能抛出异常的代码块。   
**·throw：** 用于在‘try’块中抛出异常。抛出的对象可以是任意类型。  
**·catch：** 用于捕获并处理 ‘try’块中抛出的异常。一个 ‘try’可以有多个‘catch’，用于处理不同类型的异常。 
**·finally：** 
```
#include <iostream>

void process(int x) {
    if (x < 0) {
        throw "Negative number!";
    }
    std::cout << "Processing: " << x << std::endl;
}

int main() {
    try {
        process(10);
        process(-5);
    } catch (const char* msg) {
        std::cerr << "Exception caught: " << msg << std::endl;
    }
    return 0;
}
```
在这个例子中，process 函数抛出一个 const char* 类型的异常，表示输入的数字为负数。在 main 函数中，我们使用 try 块来包含调用 process 函数的代码，并使用 catch 块捕获并处理异常。如果异常被抛出，将会打印错误消息。


**11、C++中虚的析构函数的作用是什么？为什么要定义虚析构函数？**  
在C++中，虚析构函数的作用是确保在基类指针指向派生类对象并使用 delete 删除该指针时，能够正确地调用派生类的析构函数。如果基类的析构函数不是虚函数，而基类指针指向的对象是派生类对象，那么在使用 delete 删除这个指针时，只会调用基类的析构函数，而不会调用派生类的析构函数，导致内存泄漏和资源泄漏的问题。

虚析构函数的主要作用是通过动态绑定确保在销毁对象时正确调用派生类的析构函数，从而避免潜在的内存泄漏和资源泄漏。

如果一个类带有虚函数，通常建议将析构函数声明为虚函数，以便正确释放派生类对象的资源。
```
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    ~Derived() {}
};
```

**12、什么是C++中的左值和右值，有什么特性？**  
在C++中，左值和右值是用与标识表达式的两种基本类别。  
**（1）左值：** 
左值是指可识别并具有地址的对象或表达式；  
左值可以出现在复制语句的左边和右边；  
左值可以取地址，因此可以被引用；  
通常来说，变量、数组元素、引用、函数返回左值引用等都是左值。  
**（2）右值：**  
右值是指不能取地址的临时对象或表达式，通常是在表达式求值完毕后即将被销毁的值；  
右值不能出现在赋值语句的左边，只能出现在赋值语句的右边；  
右值通常是临时对象、字面常量、函数返回值等。

========================================================

**1、什么是进程？简述进程的创建和销毁过程。**  
进程是指正在运行的程序实例。每个进程都拥有独立的内存空间和资源，包括内存、文件句柄、设备和线程等。进程是操作系统中进行资源分配和调度的基本单位，它们之间相互独立，互不影响。  
**1、进程的创建：**  
1）当一个程序被执行时，操作系统会为其创建一个新的进程。  
2）在创建进程时，操作系统会为新进程分配内存空间，并复制父进程的代码、数据、资源到新进程的地址空间中。  
3）新进程会继承父进程的环境和状态，但是拥有独立的内存空间和资源。  
4）创建进程的方式包括：  
执行可执行文件；调用‘fork()’系统调用；调用操作系统提供的进程创建函数。

**2、进程的销毁：**  
1）进程正常退出或异常退出；  
2）正常退出是指进程完成了其任务，显示地调用了退出函数 **exit()** 或返回主函数；  
3）异常退出是指进程遇到了错误或异常情况，导致进程被操作系统终止。  
4）在进程退出时，操作系统会回收进程占用的资源，释放内存空间，并向父进程发送退出状态码；  
5）进程的销毁过程也可能包括：被用户手动终止；被操作系统强制终止（如超出资源限制、死锁等情况）。

**2、什么是线程？简述线程的创建和销毁过程。**  
线程是在进程内部独立运行的最小单位。一个进程可以包含多个线程，它们共享进程的资源，包括内存空间、文件句柄等。线程可以看作是进程内部的子任务，它们可以并发地执行，共享进程的数据和状态。  
**1、线程的创建：**  
1）线程的创建可以在应用程序中显式地调用线程库提供的创建函数来完成，也可以通过操作系统提供的系统调用来创建；  
2）在创建线程时，操作系统会为新线程分配资源，包括线程的执行栈、线程的上下文、线程ID等；  
3）新线程的执行体通常是一个函数，可以是全局函数、类的成员函数或者Lambda表达式；  
4）在创建线程时，通常需要执行线程的入口函数、传递给入口函数的参数、线程的属性（如优先级，调度策略等）等信息；  
5）线程创建完成后，他将在指定的入口函数处开始执行，并于其他线程并发执行。  
**2、线程的销毁：**  
1）线程的销毁是指线程结束其执行，释放占用的资源；  
2）线程可以通过返回其入口函数、调用线程库提供的退出函数或者其他线程取消来结束执行。  
3）在线程结束执行时，操纵系统会回收线程占用的资源，包括释放执行栈、清理线程上下文等；  
4）如果线程是主线程，那么它的结束可能意味着整个进程的结束；

**3、进程和线程的区别。**  
**1、定义：**  
进程是程序执行时的一个实例，是程序的执行过程。每个进程都有独立的内存空间、资源和状态；  （资源调度的最小单位）

线程是进程内部的一个执行单元，是进程的一部分。一个进程可以包含多个线程，它们共享进程的内存空间和资源。（系统执行的最小单位）    
**2、资源占用：**  
进程拥有独立的内存空间、文件句柄、设备和线程等资源，不同进程之间的资源是独立的。

线程共享所属进程的内存空间和资源，包括内存、文件句柄等，线程之间可以方便地共享数据和状态。  
**3、创建和销毁：**  
进程的创建和销毁需要较多的系统资源和时间，包括分配内存空间、复制父进程的代码和资源等；  

线程的创建和销毁相对较快，因为线程共享进程的资源，所以创建和销毁线程的开销较小。  
**4、调度和同步：**  
进程之间的调度和通信较为复杂，需要采用进程间通信（IPC）机制，如管道、消息队列、共享内存等；  

线程之间的调度和通信相对简单，可以通过共享内存、信号量、互斥量等机制进行线程间通信和同步。  
**5、健壮性：**  
进程之间相互独立，一个进程崩溃不会影响其他进程；

线程共享进程的地址空间，一个线程的错误可能会导致整个进程的崩溃

**4、解释什么是死锁，以及如何避免死锁。**  
死锁是指在多个进程或线程之间发生的一种资源争夺的特殊情况，导致所有涉及的进程或线程无法继续执行下去，因为它们都在等待对方释放资源，从而陷入了循环等待的状态。  

要避免死锁，可以采取一下几个策略：  
**（1）避免加锁：** 尽量减少加锁的情况，或者在加锁时保持加锁顺序一致性，避免循环等待的产生；  
**（2）加锁顺序：** 确保所有线程或者进程都以相同的顺序获取锁，从而避免循环等待；
**（3）超时机制：**在获取资源时设置超时机制，如果等待超时，则放弃当前资源的获取，释放以获取的资源，然后重新尝试获取资源。

**5、解释什么是优先级反转，以及如何解决优先级反转问题。**  
优先级反转是一种并发编程中的现象，指的是具有不同优先级的进程或线程在竞争共享资源时，低优先级的进程或线程持有了高优先级的资源而导致高优先级的进程或线程被阻塞的情况。这种情况下，高优先级的进程或线程会等待低优先级的进程或线程释放资源，从而导致优先级反转。  
优先级反转的典型场景如下：  
1）高优先级任务开始执行，并尝试获取共享资源，但发现该资源已经被低优先级任务占用；  
2）由于低优先级任务持有资源，高优先级任务被阻塞；  
3）随后，中优先级任务开始执行，由于没有竞争到资源，所以无法进行下一步的运行；  
4）最终，低优先级任务完成了对资源的使用，并释放了资源。  
5）高优先级任务获得资源，但此时中优先级任务仍在运行，因此高优先级任务仍然被阻塞。  

为解决优先级反转的问题，可采取一下几种策略：  
**【1】优先级继承：** 当低优先级任务持有资源时，将其优先级提升到与高优先级任务相同的优先级，直到它释放资源为止。这样可以确保高优先级任务能够尽快获得资源。  
**【2】优先级抢占：** 操作系统可以通过抢占机制，在高优先级任务需要时使用资源时，将低优先级任务暂时挂起，以确保高优先级任务能够尽快获得资源；  
**【3】使用信号量或互斥锁：** 通过使用信号量或互斥锁等同步机制，可以确保资源的互斥访问，从而避免不同优先级任务之间的竞争和优先级反转；   

**6、什么是缓冲区溢出？如何避免缓冲区溢出？**  
缓冲区溢出是指当向缓冲区写入数据时，超出了缓冲区的边界，导致数据覆盖了相邻的内存区域。缓冲区溢出是一种常见的安全漏洞，可能被恶意攻击者利用来执行恶意代码、修改程序行为或者破坏系统稳定性。  

缓冲区溢出通常发生在以下几种情况：   

1、输入数据验证不足。  
2、使用不安全的函数。  （字符串处理函数，拷贝\拼接等）

为了避免缓冲区溢出，可以采取以下几种措施：  

**1、边界检查：** 在将数据写入缓冲区之前，始终检查输入数据的大小，确保数据不会超出缓冲区的边界。  
**2、使用安全函数：** 避免使用不安全的字符串处理函数；  
**3、内存保护技术：** 一些操作系统提供 **栈保护** 和 **地址空间随机化** ，可以在一定程度上防止缓冲区溢出攻击。

**7、什么是虚拟内存？简述虚拟内存的实现原理。**  
略  

**8、解释什么是文件系统，以及文件系统的作用。**  
文件系统是计算机系统中用于管理和组织存储在持久性存储设备（如硬盘、固态等）上的数据的一种机制或组织方式。它提供了一种逻辑上的结构，用于存储、检索和组织文件和目录，并提供了对这些文件和目录的访问和管理。  

文件系统的作用包括：  
**1、数据存储：** 文件系统提供了一种结构化的方式来存储数据。他将数据组织成文件和目录的形式，可以将文件存储在持久性设备上，以便长期保存和使用； 

**2、数据管理：** 文件系统提供了对文件和目录的管理功能，包括创建、删除、复制、移动、重命名等操作。这些操作使用户可以方便地管理和维护存储在计算机系统中的数据。  

**3、数据访问：**  文件系统的定义了对文件和目录的访问方式和权限控制机制。提供了读取、写入和执行文件的接口，以及对文件的权限控制功能，确保只有授权用户才能访问和操作文件。

**4、数据安全：**  文件系统通常提供了一些数据保护和安全功能，包括数据备份、恢复、加密和访问控制等。这些功能可以帮助用户的数据不受损坏、丢失或未经授权访问。




