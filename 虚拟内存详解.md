# 虚拟内存详解

在分析虚拟内存之前，先了解一下C/C++内存分区。

## 0 内存分区
一般来说，程序运行时，代码、数据等都存放在不同的内存区域，这些内存区域从逻辑上做了划分，大概几个区域：**代码区、全局/静态存储区、栈区和常量区。**  
![20240225162714](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225162714.png)

### 代码区（Code Segment）  
也就是 .text段，代码区存放程序的二进制代码，它是只读的，以防止程序在运行过程中被意外修改。  
这段区域也有可能包含一些只读的常数变量，例如字符串常量等。  

### 全局/静态存储区（Global/Static Storage）
**全局变量和静态变量** 都存放在全局/静态储存区。

在C语言中，全局变量分为初始化的和未初始化的，分别放在上图中的 .bss和 .data段，但在C++里面没有这个分区，它们共同占用同一块内存区，叫做全局储存区。这个区域的内存在程序的生命周期几乎都是全局的。

### 栈区（Stack）
栈区用于存储函数调用时的局部变量、函数参数以及返回地址。当函数调用完成后，分配给这个函数的栈空间会被释放。

### 堆区（Heap）
堆区是用与动态内存分配的区域，当使用new或者malloc分配内存时，分配的内存区块就位于堆区。对于在堆区中主动申请的内存，需要手动释放这些内存，否则可能导致内存泄漏。

### 常量区（Constant Storage）
常量区用于存储常量数据，例如字符串字面和其他编译时常量。这个区域通常也是只读的。

## 1  为什么需要虚拟内存？
在早期的计算机中，要运行一个程序，会把这些程序全部装入内存，程序直接运行在内存上，也就是说程序中访问的内存地址都是实际的物理内存地址。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。
 
假设当某台计算机总的内存大小是128M，现在同时运行两个程序A和B，A需要占用内存10M，B需要占用内存110M.计算机在给程序分配内存时会采取这样的方法：先将内存中的前10M分配给程序A，接着再从内存中剩余的118M中划分出10M分配给程序B。此时程序A和程序B都能运行，但是这种简单的内存分配策略问题很多，并不满足一般情况下的使用条件。  
![20240225172307](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225172307.png)

此种分配策略带来以下三个问题:  
（1）进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。  

（2）内存使用效率低。在A和B都运行的情况下，如果用户又运行了程序C，而程序C需要20M大小的内存才能运行，而此时系统只剩下8M的空间可供使用，此时系统必须在已运行的程序中选择一个程序并将该程序暂时拷贝到硬盘上，释放部分空间供C使用，然后再将程序C的数据全部装入内存运行。此过程有大量的数据在装入和装出，导致效率十分低下。  

（3）程序运行的地址不确定。当内存中的剩余空间可以满足程序C的要求后，操作系统会在剩余空间中随机分配一段连续的20M大小的空间给程序C使用，应为是随机分配的，所以程序运行的地址是不确定的。  

--------------------------------------------------------
1、让每个进程都有独立的内存空间，每个进程都有自己的私有页表，提供一个可以执行多进程的环境。  

2、利用程序运行局部性原理，允许进程的内存空间超过物理内存大小。  

3、页表维护页的权限属性，使内存访问更安全。  

物理内存到虚拟内存的映射工作是由MMU（内存管理单元）实现的。倘若没有MMU，例如单片机不存在虚拟内存，每个程序不独立，若访问了同一个地址内容，会影响到其他程序运行，造成程序崩溃。

所以：  
* 单片机上只能跑多线程，线程是调度的基本单位；  
* 要实现多进程环境还需要MMU加入提供虚拟内存环境，进程是资源分配的基本单位。


**下面内容参考自`https://www.cnblogs.com/Ethan-Code/p/16613018.html`**。 

## 2 内存分段

在没有分段时，内存的换入换出都是以整个进程内存空间为单位，非常的好事并且堆内存的利用率也不高。  
内存分段下，程序是由若干个逻辑分段组成的，如可有代码段、数据段、站段、堆段组成。  
不同的段是有不同的属性的，所以就用分段(Segmentation)的形式把这些段分离出来。

**分段机制下的虚拟地址由两个部分组成，段选择因子和段内偏移量**。

![20240225205213](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225205213.png)

* 段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。  
* 虚拟地址中的段内偏移量应该位于0和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

内存分段下的地址映射过程：  
* 虚拟地址由段选择子和段偏移量组成；
* 通过段选择子中的段号从段表中找到对应的段内描述符；
* 段描述符里提供了段基址，加上虚拟地址上的段偏移量得到物理地址；  

![20240225210014](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225210014.png)

不足之处：  
* 产生外部内存碎片；  
* 内存交换的效率低；  

**小结:**  

这种分段的映射方法虽然解决了问题1和问题3，但并没有解决问题二，即内存的使用效率问题。在分段的映射方法中，每次换入换出内存的都是整个程序，这样会造成大量的磁盘访问操作，导致效率低下。所以这种映射方法还是稍显粗糙，粒度比较大。实际上，程序的运行有局部性特点，在某个时间段内，程序只是访问程序的一小部分数据，也就是说，程序的大部分数据在一个时间段内都不会被用到。基于这种情况，提出了力度更小的内存分割和映射方法，这就是分页（Paging）。

## 3 内存分页
内存分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，成为（Page）。在linux下，每页的大小为4KB。  
![20240225211000](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225211000.png)

页表是存储在内存里的，内存管理单元（MMU）将虚拟内存地址转换成物理地址。  
当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后在返回用户空间，恢复进程的运行。采用了分页，由于内存空间都是预先划分好的，页与页之间是紧密排列的，所以不会有外部碎片。   

在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。 **分页的思想是程序运行到哪页就为哪页分配内存，没用到的暂时保留在硬盘上。** 当用到这些页时再在物理地址空间中为这些页分配内存，然后 **建立虚拟地址空间中的页和刚分配的物理内存页间的映射**。 

下面通过介绍一个可执行文件的装载过程来说明分页机制的实现方法。一个可执行文件（PE文件）其实就是一些编译链接好的数据和指令的集合，它被分成很多页。在PE文件执行的过程中，它往内存中装载的单位就是页。当一个PE文件被执行时，操作系统会先为该程序创建一个4G的进程虚拟地址空间。虚拟地址空间只是一个中间层，**它的功能是利用一种映射机制将虚拟地址空间映射到物理地址空间** ，所以创建4GB虚拟地址空间其实并不是要真的创建空间，只是创建那种映射机制所需要的数据结构，这种数据结构就是页目和页表。

当创建完虚拟地址空间所需要的数据结构后，进程开始读取PE文件的第一页。在PE文件的第一页包含了PE文件头和段表等信息，进程根据文件头和段表等信息，将PE文件中所有的段一一映射到虚拟地址空间中相应的页（PE文件中段的长度都是页长的整数倍）。

这时PE文件的真正指令和数据还没有被装入内存中，操作系统只是根据PE文件的头部等信息建立了PE文件和进程虚拟地址空间中页的映射关系而已。当CPU要访问程序中用到的某个虚拟地址时，当CPU发现该地址并没有相关联的物理地址时，CPU认为该虚拟地址所在的页面是个空页面，CPU会认为这是个页错误（Page Fault），CPU会将控制权交还给操作系统。操作系统于是为该PE页面在物理空间中分配一个页面，然后再将这个物理页面与虚拟页面映射起来，然后将控制权再还给进程，进程从刚才发生也错误的位置重新执行。此时已为PE文件的那个页面分配了内存，所以就不会发生页错误了。随着程序执行，页错误会不断产生，擦欧总系统也会为进程分配相应的物理页面来满足进程执行的需求。

分页方法的核心思想就是当可执行文件执行到第x页时，就为第x页分配一个内存页y，然后再将这个内存页添加到进程虚拟地址空间的映射表中,这个映射表就相当于一个y=f(x)函数。应用程序通过这个映射表就可以访问到x页关联的y页了。

**不足之处:** 
* 产生内部碎片

换入换出：

![20240225215839](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225215839.png) 
分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。只有在程序运行中需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。

在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址。  

![20240225215909](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225215909.png)  

对于一个内存地址转换的三个步骤：  
* 把虚拟内存地址，切分成页号和偏移量；
* 根据也好，从页表里面，查询对应的物理页号；
* 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址；

### 多级页表
![20240225220331](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225220331.png)  
多级页表节约内存：页表要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项。

对于64位的系统，两级分页不够用了，就变成了四级目录，分别是：
![20240225220447](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225220447.png)  
* 全局页目录项 PGD（Page Global Directory）；  
* 上层页目录项 PUD（Page Upper Directory）；  
* 中间页目录项 PMD（Page Middle Directory）；  
* 页表项 PTE（Page Table Entry）；  
  
### 页表缓存  
CPU里有一个专门存放程序最常访问的页表项的 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表。  

![20240225220907](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225220907.png)

在 CPU 芯片里面，封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互。

有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。

## 4 段页式内存管理
先分段后分页，地址结构就由段号、段内页号和页内位移三部分组成。  
用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页物理页号。  
![20240225221342](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225221342.png)

段页式地址变换要得到物理地址须经过三次内存访问：
* 第一次访问段表，得到页表起始地址；
* 第二次访问页表，得到物理页号；
* 第三次将物理页号与页内位移组合，得到物理地址。 
![20240225221701](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225221701.png)  

## 内存管理
Linux操作系统中，虚拟地址空间被分为内核空间和用户空间两部分。
![20240225221827](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225221827.png)

每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。
![20240225221912](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225221912.png)

虚拟空间的划分情况

![20240225221950](https://gcore.jsdelivr.net/gh/xupengfeir/Notes-and-Articles/Image/20240225221950.png)

用户空间内存，从低到高分别是6种不同的内存段：
* 程序文件段（.text）:包括二进制可执行代码；
* 已初始化数据段（.data）:包括静态常量；
* 未初始化数据段（.bss）:包括未初始化的金泰变量；
* 堆段，包括动态分配的内存，从低地址开始向上增长；
* 文件映射段，包括动态库、共享内存等，从低地址开始向上增长
* 栈段，包括局部变量和函数调用的上下文等。栈大小是固定的，一般为8MB。
  
堆 和 文件映射段 的内存是动态分配的。C标准库的malloc()或者mmap(),就可以分别在堆和文件映射段动态分配内存。
